package collections

import (
	"fmt"
)

// ValidateCollectionID validates a collection ID
func ValidateCollectionID(collectionID string) error {
	if collectionID == "" {
		return fmt.Errorf("collection ID cannot be empty")
	}
	return nil
}

// ValidateCollectionName validates a collection name
func ValidateCollectionName(name string) error {
	if name == "" {
		return fmt.Errorf("collection name cannot be empty")
	}
	return nil
}

// ValidateCreateCollectionRequest validates a create collection request
func ValidateCreateCollectionRequest(req *CreateCollectionRequest) error {
	if req == nil {
		return fmt.Errorf("create collection request cannot be nil")
	}
	if req.Data.Type != "collection" {
		return fmt.Errorf("invalid collection type: must be 'collection'")
	}
	if err := ValidateCollectionName(req.Data.Attributes.Name); err != nil {
		return err
	}
	// Either relationships or raw_items must be provided, but not both
	hasRelationships := req.Data.Relationships != nil
	hasRawItems := req.Data.RawItems != ""
	
	if !hasRelationships && !hasRawItems {
		return fmt.Errorf("either relationships or raw_items must be provided")
	}
	
	return nil
}

// ValidateUpdateCollectionRequest validates an update collection request
func ValidateUpdateCollectionRequest(req *UpdateCollectionRequest) error {
	if req == nil {
		return fmt.Errorf("update collection request cannot be nil")
	}
	if req.Data.Type != "collection" {
		return fmt.Errorf("invalid collection type: must be 'collection'")
	}
	// At least one field should be provided for update
	hasAttributes := req.Data.Attributes != nil && 
		(req.Data.Attributes.Name != "" || req.Data.Attributes.Description != "")
	hasRawItems := req.Data.RawItems != ""
	
	if !hasAttributes && !hasRawItems {
		return fmt.Errorf("at least one field must be provided for update")
	}
	
	return nil
}

// ValidateRelationship validates a relationship name
func ValidateRelationship(relationship string) error {
	if relationship == "" {
		return fmt.Errorf("relationship cannot be empty")
	}
	
	// Validate against known relationships
	validRelationships := map[string]bool{
		RelationshipAutogeneratedGraphs: true,
		RelationshipComments:            true,
		RelationshipDomains:             true,
		RelationshipFiles:               true,
		RelationshipIPAddresses:         true,
		RelationshipOwner:               true,
		RelationshipReferences:          true,
		RelationshipRelatedCollections:  true,
		RelationshipRelatedReferences:   true,
		RelationshipThreatActors:        true,
		RelationshipURLs:                true,
	}
	
	if !validRelationships[relationship] {
		return fmt.Errorf("invalid relationship: %s", relationship)
	}
	
	return nil
}

// ValidateAddItemsRequest validates an add items request
func ValidateAddItemsRequest(req *AddItemsRequest) error {
	if req == nil {
		return fmt.Errorf("add items request cannot be nil")
	}
	if len(req.Data) == 0 {
		return fmt.Errorf("items list cannot be empty")
	}
	
	// Validate each item
	for i, item := range req.Data {
		if item.Type == "" {
			return fmt.Errorf("item %d: type cannot be empty", i)
		}
		// For URLs, either ID or URL must be provided
		if item.Type == "url" {
			if item.ID == "" && item.URL == "" {
				return fmt.Errorf("item %d: for URL type, either ID or URL must be provided", i)
			}
		} else {
			// For other types, ID must be provided
			if item.ID == "" {
				return fmt.Errorf("item %d: ID cannot be empty", i)
			}
		}
	}
	
	return nil
}

// ValidateDeleteItemsRequest validates a delete items request
func ValidateDeleteItemsRequest(req *DeleteItemsRequest) error {
	if req == nil {
		return fmt.Errorf("delete items request cannot be nil")
	}
	if len(req.Data) == 0 {
		return fmt.Errorf("items list cannot be empty")
	}
	
	// Validate each item
	for i, item := range req.Data {
		if item.Type == "" {
			return fmt.Errorf("item %d: type cannot be empty", i)
		}
		// For URLs, either ID or URL must be provided
		if item.Type == "url" {
			if item.ID == "" && item.URL == "" {
				return fmt.Errorf("item %d: for URL type, either ID or URL must be provided", i)
			}
		} else {
			// For other types, ID must be provided
			if item.ID == "" {
				return fmt.Errorf("item %d: ID cannot be empty", i)
			}
		}
	}
	
	return nil
}

// ValidateCommentText validates a comment text
func ValidateCommentText(text string) error {
	if text == "" {
		return fmt.Errorf("comment text cannot be empty")
	}
	return nil
}

// ValidateAddCommentRequest validates an add comment request
func ValidateAddCommentRequest(req *AddCommentRequest) error {
	if req == nil {
		return fmt.Errorf("add comment request cannot be nil")
	}
	if req.Data.Type != "comment" {
		return fmt.Errorf("invalid comment type: must be 'comment'")
	}
	return ValidateCommentText(req.Data.Attributes.Text)
}
